Steps to make gbmv work:
1. Comment the following in Halide/src/Lower.cpp 
   Line 224
    //s = partition_loops(s);

  Line 456-457:
    //s = partition_loops(s);
    //s = simplify(s);

  Line 570:
    //s = remove_dead_dimensions(s);

2. cd Halide
   make -j

3. cd t2s/tests/performance
  ./test.sh local gbmv a10 tiny emulator

4. cd t2s/tests/performance/gbmv
   Add the following line to the generated a.cl to Line 360:
      _uX_shreg[1][_uA_s0_iii] = _uX_shreg[0][_uA_s0_iii]; 

   Explanation: this line is to shift (not rotate) the uX registers every cycle. This is because the following decision during compilation:
        env BITSTREAM=a.aocx 'AOC_OPTION=-march=emulator -board=a10gx -emulator-channel-depth-model=strict' HL_DEBUG_CODEGEN=4 ./a.out >& b
        Open b and search for the followinig lines:
		Minimizing shift registers...
                        ......
			Register allocation for uX:
        			Linearized dims: uA.s0.kkk
                			Linearized extent: 2
                			Strategy: shift
        			PE_dims: uA.s0.iii
                			Extents: 2
       As we can see, the strategy for uX is "shift" along kkk. That is why we need to insert that shift. 
	
   TODO: fix the compiler to automatically insert such shift.
 
5. Recompile a.cl and others:
  rm -rf a a.aocx
  aoc -march=emulator -board=a10gx -emulator-channel-depth-model=strict a.cl
  
  // THe following two commands are copied from the output of the above ./test.sh command:
  g++ gbmv-run-fpga.cpp gbmv-interface.cpp ../../../src/AOT-OpenCL-Runtime.cpp ../../../src/Roofline.cpp ../../../src/SharedUtilsInC.cpp -g -DLINUX -DALTERA_CL -fPIC -I../../../src/ -I $T2S_PATH/Halide/include -I$INTELFPGAOCLSDKROOT/examples_aoc/common/inc $INTELFPGAOCLSDKROOT/examples_aoc/common/src/AOCLUtils/opencl.cpp $INTELFPGAOCLSDKROOT/examples_aoc/common/src/AOCLUtils/options.cpp -I$INTELFPGAOCLSDKROOT/host/include -L$INTELFPGAOCLSDKROOT/linux64/lib -L$AOCL_BOARD_PACKAGE_ROOT/linux64/lib -L$INTELFPGAOCLSDKROOT/host/linux64/lib -lOpenCL -L $T2S_PATH/Halide/bin -lelf -lHalide -DTINY -lz -lpthread -ldl -std=c++11 -o ./b.out
  env BITSTREAM=a.aocx CL_CONTEXT_EMULATOR_DEVICE_INTELFPGA=1 'INTEL_FPGA_OCL_PLATFORM_NAME=Intel(R) FPGA SDK for OpenCL(TM)' ./b.out

We should see the following results, which seem correct: 

0 0 2 11 20 29 38 47 
0 1 10 19 28 37 46 55 
0 9 18 27 36 45 54 63 
8 17 26 35 44 53 62 0 
16 25 34 43 52 61 0 0 
TOTAL_K: 8
bandedA.dim(0).extent() = 8, bandedA.dim(1).extent() = 8
extendedI: 4
X server found. dri2 connection failed! 
Device open failed, aborting...
Initializing IDs
Intel(R) Corporation
Total number of devices: 1

===== Host-CPU setting up OpenCL program and kernels ======

Create program with binary
Creating kernel[0]: kernel_aLoader
Creating kernel[1]: kernel_aFeeder
Creating kernel[2]: kernel_xLoader
Creating kernel[3]: kernel_xFeeder
Creating kernel[4]: kernel_V
Creating kernel[5]: kernel_yLoader
Creating kernel[6]: kernel_yFeeder
Creating kernel[7]: kernel_Out
Creating kernel[8]: kernel_drainer
Creating kernel[9]: kernel_collector
Creating kernel[10]: kernel_unloader
All kernels created
halide_opencl_buffer_copy: host to host copy with source address equal to destination address. Do nothing. 
Command queue 0: copying 512 bytes data from host to device. Done.
halide_opencl_buffer_copy: host to host copy with source address equal to destination address. Do nothing. 
Command queue 2: copying 512 bytes data from host to device. Done.
halide_opencl_buffer_copy: host to host copy with source address equal to destination address. Do nothing. 
Command queue 5: copying 64 bytes data from host to device. Done.

===== Host-CPU enqeuing the OpenCL kernels to the FPGA device ======

clEnqueueNDRangeKernel[0]: kernel_aLoader!
clEnqueueNDRangeKernel[1]: kernel_aFeeder!
clEnqueueNDRangeKernel[2]: kernel_xLoader!
clEnqueueNDRangeKernel[3]: kernel_xFeeder!
clEnqueueNDRangeKernel[4]: kernel_V!
clEnqueueNDRangeKernel[5]: kernel_yLoader!
clEnqueueNDRangeKernel[6]: kernel_yFeeder!
clEnqueueNDRangeKernel[7]: kernel_Out!
clEnqueueNDRangeKernel[8]: kernel_drainer!
clEnqueueNDRangeKernel[9]: kernel_collector!
clEnqueueNDRangeKernel[10]: kernel_unloader!

 *** FPGA execution started!
cmd queue: 0
cmd queue: 1
cmd queue: 2
cmd queue: 3
cmd queue: 4
cmd queue: 5
cmd queue: 6
cmd queue: 7
cmd queue: 8
cmd queue: 9
cmd queue: 10
 *** FPGA execution finished!

Command queue 11: copying 64 bytes data from device to host. Done.
halide_opencl_buffer_copy: host to host copy with source address equal to destination address. Do nothing. 
(0,1,0) 5 5
(0,1,1) 63 63
(1,0,0) 192 192
(1,0,1) 418 418
(1,1,0) 734 734
(1,1,1) 1140 1140
(2,0,0) 1188 1188
(2,0,1) 1125 1125
Success

